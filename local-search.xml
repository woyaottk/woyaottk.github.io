<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>蓝蓝计算机考研算法-day05</title>
    <link href="/2023/03/03/%E8%93%9D%E8%93%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95-day05/"/>
    <url>/2023/03/03/%E8%93%9D%E8%93%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95-day05/</url>
    
    <content type="html"><![CDATA[<p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。 </p><blockquote><p>思路：</p></blockquote><p>反正链表题都一样，只要题目没说明空间要求就用“空间换智商”管他三七二十一全部都把链表转数组，然后用数组操作即可</p><blockquote><p>代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    ListNode* cur = head;<br>    <span class="hljs-keyword">while</span>(cur) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝蓝计算机考研算法训练二期-day04</title>
    <link href="/2023/03/01/%E8%93%9D%E8%93%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E4%BA%8C%E6%9C%9F-day04/"/>
    <url>/2023/03/01/%E8%93%9D%E8%93%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E4%BA%8C%E6%9C%9F-day04/</url>
    
    <content type="html"><![CDATA[<h1 id="计算字符的个数"><a href="#计算字符的个数" class="headerlink" title="计算字符的个数"></a>计算字符的个数</h1><p>写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字符，然后输出输入字符串中该字符的出现次数。（不区分大小写字母）</p><p>数据范围： 1 &lt;&#x3D; n&lt;&#x3D;1000</p><blockquote><p>输入描述</p></blockquote><p>第一行输入一个由字母、数字和空格组成的字符串，第二行输入一个字符（保证该字符不为空格）。</p><blockquote><p>输出描述：</p></blockquote><p>输出输入字符串中含有该字符的个数。（不区分大小写字母）</p><blockquote><p>思路</p></blockquote><p>获取一行数据，然后将所有字符都变为小写或大写，最后统一存在哈希表当中</p><blockquote><p>代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string s;<br><span class="hljs-type">int</span> map[<span class="hljs-number">255</span>];<br><span class="hljs-built_in">getline</span>(cin, s);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br><span class="hljs-keyword">if</span> (c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; c &gt;= <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>c = <span class="hljs-built_in">tolower</span>(c);<br>&#125;<br>map[c]++;<br>&#125;<br><span class="hljs-type">char</span> op;<br>cin &gt;&gt; op;<br>op = <span class="hljs-built_in">tolower</span>(op);<br>cout &lt;&lt; map[op];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝蓝计算机考研算法-day03</title>
    <link href="/2023/03/01/%E8%93%9D%E8%93%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95-day03/"/>
    <url>/2023/03/01/%E8%93%9D%E8%93%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95-day03/</url>
    
    <content type="html"><![CDATA[<h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><p>一个小球从10处落下，每次的弹回之前的高度一半，请问小球在静止之前一共走过多少距离？</p><blockquote><p>思路</p></blockquote><p>每次计算一次下降路程路径+上升过程路径</p><blockquote><p>代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> high)</span> </span>&#123;<br><span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (high &gt; <span class="hljs-number">1e-8</span>) &#123;<br><span class="hljs-comment">//下降过程路径</span><br>sum += high;<br>high /= <span class="hljs-number">2</span>;<br><span class="hljs-comment">//上升过程路径</span><br>sum += high;<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h1><p>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送——只要读入的字符串满足下列条件，系统就输出”“答案正确”，否则输出“答案错误”。</p><p>得到“答案正确”的条件是：</p><p>1.字符串中必须仅有P、A、T这三种字符，不可以包含其它字符;</p><p>2.任意形如PATx的字符串都可以获得“答案正确”，其中x或者是空字符串，或者是仅由字母A组成的字符串:</p><p>3.如果aPbTc是正确的，那么aPbATca也是正确的，其中a、b、c均或者是空字符串，或者是仅由字母A组成的字符串。</p><p>现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。</p><blockquote><p><strong>输入格式：</strong></p></blockquote><p>每个测试输入包含1个测试用例。第1给出一个正整数n(≤10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。</p><blockquote><p><strong>输出格式：</strong></p></blockquote><p>每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出<code>YES</code>,否则输出<code>NO</code></p><blockquote><p><strong>思路</strong></p></blockquote><ol><li>只能有一个P和一个T</li><li>中间不能没有A</li><li>开头的A的个数 * 中间的A的个数 &#x3D; 结尾的A的个数</li></ol><blockquote><p>代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-comment">//用l表示P第一次出现的下标，r表示T第一次出现的下标</span><br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>, r = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//遍历每个字符</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br><span class="hljs-type">char</span> c = s[i];<br><span class="hljs-comment">//如果如果PAT这三种字符直接返回false</span><br><span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;P&#x27;</span> &amp;&amp; c != <span class="hljs-string">&#x27;T&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//如果P之前未出现过那就把这个下标赋给l</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;P&#x27;</span> &amp;&amp; l == <span class="hljs-number">-1</span>) l = i;<br><span class="hljs-comment">//如果P之前出现过直接返回false</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;P&#x27;</span> &amp;&amp; l != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//如果T之前未出现过那就把这个下标赋给l</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;T&#x27;</span> &amp;&amp; r == <span class="hljs-number">-1</span>) r = i;<br><span class="hljs-comment">//如果T之前出现过直接返回false</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;T&#x27;</span> &amp;&amp; r != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//如果中级没有A直接返回false</span><br><span class="hljs-keyword">if</span> (r - l - <span class="hljs-number">1</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//前面的A个数乘以中级A的个数是否等于最后面A的个数</span><br><span class="hljs-keyword">return</span> l * (r - l - <span class="hljs-number">1</span>) == s.<span class="hljs-built_in">length</span>() - r - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n;<br>string s;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>cin &gt;&gt; s;<br><span class="hljs-type">bool</span> flag = <span class="hljs-built_in">check</span>(s);<br><span class="hljs-keyword">if</span> (flag) cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝蓝计算机考研算法-day02</title>
    <link href="/2023/02/28/%E8%93%9D%E8%93%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95-day02/"/>
    <url>/2023/02/28/%E8%93%9D%E8%93%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95-day02/</url>
    
    <content type="html"><![CDATA[<h1 id="3-计算字符串中含有的不同字符的个数"><a href="#3-计算字符串中含有的不同字符的个数" class="headerlink" title="3.计算字符串中含有的不同字符的个数"></a>3.计算字符串中含有的不同字符的个数</h1><p>编写一个函数，计算字符串中含有的不同字符的个数。字符在ASCII码范围内（0~127，包括0和127），换行表示结束符，不在字符里。不在范围内的不作统计。多个相同的字符只计算一次</p><p>例如，对于字符串abaca而言，有a、b、c三个不同的字符，因此输出3。</p><p>数据范围：1&lt;&#x3D;n&lt;&#x3D;500</p><blockquote><p>输入描述</p></blockquote><p>输入一行没有空格的字符串。</p><blockquote><p>输出描述</p></blockquote><p>输出字符串中范围在（0~127，包括0和127）字符的种数。</p><blockquote><p>思路</p></blockquote><p>可以采用一个hashset来存储字符串中字符出现的个数。但题目又只限定于字符，故采用数组即可实现hashset的功能</p><blockquote><p>代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_count</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> mp[<span class="hljs-number">255</span>]&#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>        <span class="hljs-keyword">if</span> (!mp[c]++) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-从键盘输入两个数字n，m，求解m和n的最小公倍数。"><a href="#4-从键盘输入两个数字n，m，求解m和n的最小公倍数。" class="headerlink" title="4.从键盘输入两个数字n，m，求解m和n的最小公倍数。"></a>4.从键盘输入两个数字n，m，求解m和n的最小公倍数。</h1><blockquote><p>思路</p></blockquote><p>使用辗转相除法得到最大公约数d，然后m*n&#x2F;d就是最小公倍数</p><blockquote><p>代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">求两个正整数 a 和 b 的 最大公约数 d</span><br><span class="hljs-comment">则有 gcd(a,b) = gcd(b,a%b)</span><br><span class="hljs-comment">证明：</span><br><span class="hljs-comment">    设a%b = a - k*b 其中k = a/b(向下取整)</span><br><span class="hljs-comment">    若d是(a,b)的公约数 则知 d|a 且 d|b 则易知 d|a-k*b 故d也是(b,a%b) 的公约数</span><br><span class="hljs-comment">    若d是(b,a%b)的公约数 则知 d|b 且 d|a-k*b 则 d|a-k*b+k*b = d|a 故而d|b 故而 d也是(a,b)的公约数</span><br><span class="hljs-comment">    因此(a,b)的公约数集合和(b,a%b)的公约数集合相同 所以他们的最大公约数也相同 证毕#</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b,a%b):a; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">gcd</span>(a,b);<br>    <span class="hljs-keyword">return</span> a * b / d;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝蓝计算机考研算法-day01判断素数和计算完全数</title>
    <link href="/2023/02/27/%E8%93%9D%E8%93%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95-day01%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0%E5%92%8C%E8%AE%A1%E7%AE%97%E5%AE%8C%E5%85%A8%E6%95%B0/"/>
    <url>/2023/02/27/%E8%93%9D%E8%93%9D%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95-day01%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0%E5%92%8C%E8%AE%A1%E7%AE%97%E5%AE%8C%E5%85%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><p>从键盘输入一个整数，判断该数是否为素数（质数）。素数是指再大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 3</span><br><span class="hljs-section">输出: true</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="1-暴力算法"><a href="#1-暴力算法" class="headerlink" title="1 暴力算法"></a>1 暴力算法</h3><p>for循环全部数字判断是否能整除</p><h3 id="2-i-i"><a href="#2-i-i" class="headerlink" title="2 i*i"></a>2 i*i</h3><p>用<code>i*i &lt;= n</code>的方式来缩小遍历范围，缺点是可能会导致越界</p><h3 id="3-sqrt"><a href="#3-sqrt" class="headerlink" title="3 sqrt"></a>3 sqrt</h3><p>使用sqrt函数其实就是上面那个方法的优化，或者说是另一种写法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(p); i++)<br>        <span class="hljs-keyword">if</span> (p % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h1><p>求解从2到20000的所有完全数，完全数是指它所有的真因子（即除了自身以外的约数）的和（即因子函数），恰好等于它本身。 例如：28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14&#x3D;28。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 20000</span><br><span class="hljs-section">输出: 6 2 8496 8128</span><br><span class="hljs-section">说明: 输出了2~20000内的完全数</span><br></code></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>如果p是质数，且2^p-1 也是质数，那么（2^p-1）X 2^（p-1）便是一个完全数。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(p &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(p); i++) &#123;<br><span class="hljs-keyword">if</span> (p % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_prime</span>(i)) v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_perfect_number</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = <span class="hljs-built_in">get_primes</span>(n);<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p : v) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, p) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_prime</span>(t) &amp;&amp; t * p &lt;= n) res.<span class="hljs-built_in">push_back</span>(t * p);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python基础语法笔记</title>
    <link href="/2022/11/29/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/29/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Python 中的变量赋值不需要类型声明。<br>每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。<br>每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。<br>等号 &#x3D; 用来给变量赋值。<br>等号 &#x3D; 运算符左边是一个变量名，等号 &#x3D; 运算符右边是存储在变量中的值。</p><h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>Python有六个标准的数据类型：</p><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li><li>Boolean（布尔）</li></ul><p><img src="/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/image-20220518163608168.png" alt="image-20220518163608168"></p><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>标识符由字母、下划线和数字组成，且数字不能开头</p><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">and</span>     <span class="hljs-keyword">as</span>      <span class="hljs-keyword">assert</span>     <span class="hljs-keyword">break</span>     <span class="hljs-keyword">class</span>      <span class="hljs-title class_">continue</span>    <span class="hljs-keyword">def</span>     <span class="hljs-title function_">del</span><br><span class="hljs-keyword">elif</span>    <span class="hljs-keyword">else</span>    <span class="hljs-keyword">except</span>     <span class="hljs-built_in">exec</span>      <span class="hljs-keyword">finally</span>    <span class="hljs-keyword">for</span>         <span class="hljs-keyword">from</span>    <span class="hljs-keyword">global</span><br><span class="hljs-keyword">if</span>      <span class="hljs-keyword">in</span>      <span class="hljs-keyword">import</span>     <span class="hljs-keyword">is</span>        <span class="hljs-keyword">lambda</span>     <span class="hljs-keyword">not</span>         <span class="hljs-keyword">or</span>      <span class="hljs-keyword">pass</span><br><span class="hljs-built_in">print</span>   <span class="hljs-keyword">raise</span>   <span class="hljs-keyword">return</span>     <span class="hljs-keyword">try</span>       <span class="hljs-keyword">while</span>      <span class="hljs-keyword">with</span>        <span class="hljs-keyword">yield</span><br></code></pre></td></tr></table></figure><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><h3 id="常用的格式符号"><a href="#常用的格式符号" class="headerlink" title="常用的格式符号"></a>常用的格式符号</h3><p>下面是完整的，它可以与％符号使用列表:</p><table><thead><tr><th align="center">格式符号</th><th align="center">转换</th></tr></thead><tbody><tr><td align="center">%c</td><td align="center">字符</td></tr><tr><td align="center">%s</td><td align="center">字符串</td></tr><tr><td align="center">%d</td><td align="center">有符号十进制整数</td></tr><tr><td align="center">%u</td><td align="center">无符号十进制整数</td></tr><tr><td align="center">%o</td><td align="center">八进制整数</td></tr><tr><td align="center">%x</td><td align="center">十六进制整数（小写字母0x）</td></tr><tr><td align="center">%X</td><td align="center">十六进制整数（大写字母0X）</td></tr><tr><td align="center">%f</td><td align="center">浮点数</td></tr><tr><td align="center">%e</td><td align="center">科学计数法（小写’e’）</td></tr><tr><td align="center">%E</td><td align="center">科学计数法（大写“E”）</td></tr><tr><td align="center">%g</td><td align="center">％f和％e 的简写</td></tr><tr><td align="center">%G</td><td align="center">％f和％E的简写</td></tr></tbody></table><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><ul><li>input()的小括号中放入的是，提示信息，用来在获取数据之前给用户的一个简单提示</li><li>input()在从键盘获取了数据以后，会存放到等号右边的变量中</li><li>input()会把用户输入的任何值都作为<strong>字符串</strong>来对待</li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>下面以a&#x3D;15 ,b&#x3D;10为例进行计算</p><table><thead><tr><th align="left">运算符</th><th align="center">描述</th><th>实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="center">加</td><td>两个对象相加 a + b 输出结果 25</td></tr><tr><td align="left">-</td><td align="center">减</td><td>得到负数或是一个数减去另一个数 a - b 输出结果 5</td></tr><tr><td align="left">*</td><td align="center">乘</td><td>两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 150</td></tr><tr><td align="left">&#x2F;</td><td align="center">除</td><td>b &#x2F; a 输出结果 1.5</td></tr><tr><td align="left">&#x2F;&#x2F;</td><td align="center">取整除</td><td>返回商的整数部分 15&#x2F;&#x2F;10 输出结果 1 , 15.0&#x2F;&#x2F;10 输出结果 1.0</td></tr><tr><td align="left">%</td><td align="center">取余</td><td>返回除法的余数 b % a 输出结果 5</td></tr><tr><td align="left">**</td><td align="center">指数</td><td>a**b 为15的10次方， 输出结果 576650390625</td></tr></tbody></table><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;</td><td align="left">检查两个操作数的值是否相等，如果是则条件变为真。</td><td align="left">如a&#x3D;3,b&#x3D;3，则（a &#x3D;&#x3D; b) 为 True</td></tr><tr><td align="left">!&#x3D;</td><td align="left">检查两个操作数的值是否相等，如果值不相等，则条件变为真。</td><td align="left">如a&#x3D;1,b&#x3D;3，则(a !&#x3D; b) 为 True</td></tr><tr><td align="left">&gt;</td><td align="left">检查左操作数的值是否大于右操作数的值，如果是，则条件成立。</td><td align="left">如a&#x3D;7,b&#x3D;3，则(a &gt; b) 为 True</td></tr><tr><td align="left">&lt;</td><td align="left">检查左操作数的值是否小于右操作数的值，如果是，则条件成立。</td><td align="left">如a&#x3D;7,b&#x3D;3，则(a &lt; b) 为 False</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。</td><td align="left">如a&#x3D;3,b&#x3D;3，则(a &gt;&#x3D; b) 为 True</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。</td><td align="left">如a&#x3D;3,b&#x3D;3，则(a &lt;&#x3D; b) 为 True</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th align="left">运算符</th><th>逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td>x and y</td><td align="left">布尔”与”：如果 x 为 False，x and y 返回 False，否则它返回 y 的值。</td><td align="left">True and False， 返回 False。</td></tr><tr><td align="left">or</td><td>x or y</td><td align="left">布尔”或”：如果 x 是 True，它返回 True，否则它返回 y 的值。</td><td align="left">False or True， 返回 True。</td></tr><tr><td align="left">not</td><td>not x</td><td align="left">布尔”非”：如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not True 返回 False, not False 返回 True</td></tr></tbody></table><h1 id="常用的数据类型转换"><a href="#常用的数据类型转换" class="headerlink" title="常用的数据类型转换"></a>常用的数据类型转换</h1><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">int(x [,base ])</td><td align="center">将x转换为一个整数</td></tr><tr><td align="center">float(x )</td><td align="center">将x转换为一个浮点数</td></tr><tr><td align="center">complex(real [,imag ])</td><td align="center">创建一个复数，real为实部，imag为虚部</td></tr><tr><td align="center">str(x )</td><td align="center">将对象 x 转换为字符串</td></tr><tr><td align="center">repr(x )</td><td align="center">将对象 x 转换为表达式字符串</td></tr><tr><td align="center">eval(str )</td><td align="center">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td align="center">tuple(s )</td><td align="center">将序列 s 转换为一个元组</td></tr><tr><td align="center">list(s )</td><td align="center">将序列 s 转换为一个列表</td></tr><tr><td align="center">chr(x )</td><td align="center">将一个整数转换为一个Unicode字符</td></tr><tr><td align="center">ord(x )</td><td align="center">将一个字符转换为它的ASCII整数值</td></tr><tr><td align="center">hex(x )</td><td align="center">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="center">oct(x )</td><td align="center">将一个整数转换为一个八进制字符串</td></tr><tr><td align="center">bin(x )</td><td align="center">将一个整数转换为一个二进制字符串</td></tr></tbody></table><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> 要判断的条件<span class="hljs-number">1</span>:<br>条件成立时，要做的事情<br><span class="hljs-keyword">elif</span> 要判断的条件<span class="hljs-number">2</span>:<br>    条件成立时，要做的事情<br><span class="hljs-keyword">else</span>:<br>    否则，要做的事情<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> if <span class="hljs-selector-tag">a</span> &gt; <span class="hljs-selector-tag">b</span> else <span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><p>如果 a &gt; b的条件成立,三目运算的结果是a,否则就是b</p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> 条件:<br>    条件满足时，做的事情<span class="hljs-number">1</span><br>    条件满足时，做的事情<span class="hljs-number">2</span><br>    条件满足时，做的事情<span class="hljs-number">3</span><br>    ...(省略)...<br></code></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 临时变量 <span class="hljs-keyword">in</span> 列表或者字符串等可迭代对象:<br>    循环满足条件时执行的代码<br></code></pre></td></tr></table></figure><h1 id="容器：字符串、列表、元组、字典"><a href="#容器：字符串、列表、元组、字典" class="headerlink" title="容器：字符串、列表、元组、字典"></a>容器：字符串、列表、元组、字典</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>f-strings 提供一种简洁易读的方式, 可以在字符串中包含 Python 表达式. f-strings 以字母 ‘f’ 或 ‘F’ 为前缀, 格式化字符串使用<strong>一对单引号、双引号、三单引号、三双引号</strong>. </p><p>类似EL表达式</p><p><strong>字符串实际上就是字符的数组，所以支持下标索引</strong></p><blockquote><p>切片：</p></blockquote><h4 id="切片的语法：-起始-结束-步长"><a href="#切片的语法：-起始-结束-步长" class="headerlink" title="切片的语法：[起始:结束:步长]"></a>切片的语法：[起始:结束:步长]</h4><p><strong>注意：选取的区间从”起始”位开始，到”结束”位的前一位结束（不包含结束位本身)，步长表示选取间隔。</strong></p><blockquote><p>常见方法：</p></blockquote><ul><li>find（）：检测 str 是否包含在 mystr中，如果是返回开始的索引值，否则返回-1</li><li>index（）：跟find()方法一样，只不过如果str不在 mystr中会报一个异常.</li><li>count（）：返回 str在start和end之间 在 mystr里面出现的次数</li><li>replace（）：把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次.</li><li>split（）：以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅分隔 maxsplit+1 个子字符串</li><li>join（）：将 mystr 插入到 str 中每个元素之间,构造出一个新的字符串</li></ul><blockquote><p>其余常用方法：</p></blockquote><ul><li>capitaliz（）：把字符串的第一个字符大写</li><li>title（）：把字符串的每个单词首字母大写</li><li>startwith（）：检查字符串是否是以 hello 开头, 是则返回 True，否则返回 False</li><li>endswith（）：检查字符串是否以obj结束，如果是返回True,否则返回 False.</li><li>lower（）：转换 mystr 中所有大写字符为小写</li><li>upper（）：转换 mystr 中所有大写字符为小写</li><li>ljust（）：返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</li><li>rjust（）：返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</li><li>center（）：返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</li><li>lstrip（）：删除 mystr 左边的空白字符</li><li>rstrip（）：删除 mystr 字符串末尾的空白字符</li><li>strip（）：删除mystr字符串两端的空白字符</li><li>rfind（）：类似于 find()函数，不过是从右边开始查找.</li><li>rindex（）：类似于 index()，不过是从右边开始.</li><li>partition（）：把mystr以str分割成三部分,str前，str和str后</li><li>rpartition（）：类似于 partition()函数,不过是从右边开始.</li><li>splitlines（）：按照行分隔，返回一个包含各行作为元素的列表</li><li>isalpha（）：如果 mystr 所有字符都是字母 则返回 True,否则返回 False</li><li>isdigit（）：如果 mystr 只包含数字则返回 True 否则返回 False.</li><li>isalnum（）：如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False</li><li>isspace（）：如果 mystr 中只包含空格，则返回 True，否则返回 False.</li></ul><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>比C语言的数组强大的地方在于列表中的元素可以是不同类型的</p><blockquote><p>常用方法：</p></blockquote><ul><li>append（）：通过append可以向列表添加元素</li><li>extend（）：通过extend可以将另一个集合中的元素逐一添加到列表中</li><li>insert（）：insert(index, object) 在指定位置index前插入元素object</li><li>index（）：index与字符串中的用法相同</li><li>count（）：count与字符串中的用法相同</li><li>pop（）：删除最后一个元素</li><li>remove（）：根据元素的值进行删除</li><li>sort（）：sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse&#x3D;True可改为倒序，由大到小。</li><li>reverse（）：reverse方法是将list逆置。</li></ul><blockquote><p>列表推导式：</p></blockquote><p>所谓的列表推导式，就是指的轻量级循环创建列表</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">a = [(x, y, z) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>)]<br></code></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>Python的元组与列表类似，不同之处在于<strong>元组的元素不能修改</strong>。元组使用小括号，列表使用方括号。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul><li>字典和列表一样，也能够存储多个数据</li><li>列表中找某个元素时，是根据下标进行的</li><li>字典中找某个元素时，是根据’名字’（就是冒号:前面的那个值，例如上面代码中的’name’、’id’、’sex’）</li><li>字典的每个元素由2部分组成，键:值。例如 ‘name’:’班长’ ,’name’为键，’班长’为值</li><li>用{}包起来</li></ul><blockquote><p>常用方法：</p></blockquote><ul><li>get（）：除了使用key查找数据，还可以使用get来获取数据</li><li>clear（）：clear清空整个字典</li><li>keys（）：keys返回一个包含字典所有KEY的列表</li><li>values（）：返回一个包含字典所有value的列表</li><li>items（）：返回一个包含所有（键，值）元祖的列表</li></ul><h2 id="公用方法"><a href="#公用方法" class="headerlink" title="公用方法"></a>公用方法</h2><h3 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1. 运算符"></a>1. 运算符</h3><table><thead><tr><th align="left">运算符</th><th>Python 表达式</th><th>结果</th><th>描述</th><th>支持的数据类型</th></tr></thead><tbody><tr><td align="left">+</td><td>[1, 2] + [3, 4]</td><td>[1, 2, 3, 4]</td><td>合并</td><td>字符串、列表、元组</td></tr><tr><td align="left">*</td><td>[‘Hi!’] * 4</td><td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td>复制</td><td>字符串、列表、元组</td></tr><tr><td align="left">in</td><td>3 in (1, 2, 3)</td><td>True</td><td>元素是否存在</td><td>字符串、列表、元组、字典</td></tr><tr><td align="left">not in</td><td>4 not in (1, 2, 3)</td><td>True</td><td>元素是否不存在</td><td>字符串、列表、元组、字典</td></tr></tbody></table><h3 id="2-python内置函数"><a href="#2-python内置函数" class="headerlink" title="2. python内置函数"></a>2. python内置函数</h3><p>Python包含了以下内置函数</p><table><thead><tr><th align="left">序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td align="left">1</td><td>len(item)</td><td>计算容器中元素个数</td></tr><tr><td align="left">2</td><td>max(item)</td><td>返回容器中元素最大值</td></tr><tr><td align="left">3</td><td>min(item)</td><td>返回容器中元素最小值</td></tr><tr><td align="left">4</td><td>del(item)</td><td>删除变量</td></tr></tbody></table><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数名</span>():<br>    代码<br></code></pre></td></tr></table></figure><p>要在函数里使用全局变量那么得使用global</p><blockquote><p> 缺省参数：</p></blockquote><ul><li>在形参中默认有值的参数，称之为缺省参数</li><li>注意：带有默认值的参数一定要位于参数列表的最后面</li></ul><blockquote><p>不定长参数：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">functionname</span>(<span class="hljs-params">[formal_args,] *args, b=<span class="hljs-number">22</span>, **kwargs</span>):<br>   <span class="hljs-string">&quot;&quot;&quot;函数_文档字符串&quot;&quot;&quot;</span><br>   function_suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><ul><li><p>加了星号（*）的变量args会存放所有未命名的变量参数，args为元组</p></li><li><p>而加**的变量kwargs会存放命名参数，即形如key&#x3D;value的参数， kwargs为字典.</p></li><li><p>如果很多个值都是不定长参数，那么这种情况下，可以将缺省参数放到 *args的后面， 但如果有<strong>kwargs的话，</strong>kwargs必须是最后的</p></li></ul><blockquote><p>拆包、交换变量的值</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_my_info</span>():<br>    high = <span class="hljs-number">178</span><br>    weight = <span class="hljs-number">100</span><br>    age = <span class="hljs-number">18</span><br>    <span class="hljs-keyword">return</span> high, weight, age<br><br><br>my_high, my_weight, my_age = get_my_info()<br></code></pre></td></tr></table></figure><ul><li>拆包时要注意，需要拆的数据的个数要与变量的个数相同，否则程序会异常</li><li>除了对元组拆包之外，还可以对列表、字典等拆包</li></ul><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>Python中函数参数是值传递</li><li>所谓可变类型与不可变类型是指：数据能够直接进行修改，如果能直接修改那么就是可变，否则是不可变</li><li>可变类型有： 列表、字典、集合</li><li>不可变类型有： 数字、字符串、元组</li><li>对于不可变类型，因变量不能修改，所以运算不会影响到变量自身</li><li>而对于可变类型来说，函数体中的运算有可能会更改传入的参数变量</li></ul><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><blockquote><p>写数据(write)</p></blockquote><p>首先打开文件<br>然后使用write()可以完成向文件写入数据<br>最后关闭文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;hello world, i am here!&#x27;</span>)<br>f.close()<br></code></pre></td></tr></table></figure><ul><li>如果文件不存在那么创建，如果存在那么就先清空，然后写入数据</li></ul><blockquote><p>读数据（read）</p></blockquote><p>首先打开文件<br>然后使用read()可以完成从文件读出数据<br>最后关闭文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br>content = f.read(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 最多读取5个数据</span><br><span class="hljs-built_in">print</span>(content)<br>f.close()  <span class="hljs-comment"># 关闭文件，这个可以是个好习惯哦</span><br></code></pre></td></tr></table></figure><ul><li><p>如果用open打开文件时，如果使用的”r”，那么可以省略，即只写 <code>open(&#39;test.txt&#39;)</code></p></li><li><p>read（）：读字节</p></li><li><p>readline（）：读一行</p></li><li><p>readlines（）：读全部</p></li></ul><blockquote><p>文件重命名：</p></blockquote><p>os模块中的rename()可以完成对文件的重命名操作</p><p>rename(需要修改的文件名, 新的文件名)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.rename(<span class="hljs-string">&quot;毕业论文.txt&quot;</span>, <span class="hljs-string">&quot;毕业论文-最终版.txt&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>删除文件：</p></blockquote><p>os模块中的remove()可以完成对文件的删除操作</p><p>remove(待删除的文件名)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.remove(<span class="hljs-string">&quot;毕业论文.txt&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>创建文件夹：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.mkdir(<span class="hljs-string">&quot;张三&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>获取当前路径：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.getcwd()<br></code></pre></td></tr></table></figure><blockquote><p>改变默认目录</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.chdir(<span class="hljs-string">&quot;../&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>获取目录列表：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.listdir(<span class="hljs-string">&quot;./&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>删除文件夹：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.rmdir(<span class="hljs-string">&quot;张三&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">类名</span>:<br>    方法列表<br></code></pre></td></tr></table></figure><ul><li>定义类时有2种形式：新式类和经典类，上面代码中的Hero为新式类，前两行注释部分则为经典类；</li><li>object 是Python 里所有类的最顶级父类；</li><li>类名 的命名规则按照”大驼峰命名法”；</li><li>info 是一个实例方法，第一个参数一般是self，表示实例对象本身，当然了可以将self换为其它的名字，其作用是一个变量 这个变量指向了实例对象</li></ul><p>属性可以在类外面用.属性的方式添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 给对象添加属性，以及对应的属性值</span><br>taidamier.name = <span class="hljs-string">&quot;泰达米尔&quot;</span>  <span class="hljs-comment"># 姓名</span><br>taidamier.hp = <span class="hljs-number">2600</span>  <span class="hljs-comment"># 生命值</span><br>taidamier.atk = <span class="hljs-number">450</span>  <span class="hljs-comment"># 攻击力</span><br>taidamier.armor = <span class="hljs-number">200</span>  <span class="hljs-comment"># 护甲值</span><br></code></pre></td></tr></table></figure><p>也可以使用构造函数来添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; 方法，用来做变量初始化 或 赋值 操作，在类实例化对象的时候，会被自动调用&quot;&quot;&quot;</span><br>    self.name = <span class="hljs-string">&quot;泰达米尔&quot;</span> <span class="hljs-comment"># 姓名</span><br>    self.hp = <span class="hljs-number">2600</span> <span class="hljs-comment"># 生命值</span><br>    self.atk = <span class="hljs-number">450</span>  <span class="hljs-comment"># 攻击力</span><br>    self.armor = <span class="hljs-number">200</span>  <span class="hljs-comment"># 护甲值</span><br></code></pre></td></tr></table></figure><p>内部方式使用self来获取属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">info</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;在类的实例方法中，通过self获取该对象的属性&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;英雄 %s 的生命值 :%d&quot;</span> % (self.name, self.hp))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;英雄 %s 的攻击力 :%d&quot;</span> % (self.name, self.atk))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;英雄 %s 的护甲值 :%d&quot;</span> % (self.name, self.armor))<br></code></pre></td></tr></table></figure><blockquote><p>构造函数</p></blockquote><p><code>__init__()</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;定义了一个英雄类，可以移动和攻击&quot;&quot;&quot;</span><br><span class="hljs-comment"># Python 的类里提供的，两个下划线开始，两个下划线结束的方法，就是魔法方法，__init__()就是一个魔法方法，通常用来做属性初始化 或 赋值 操作。</span><br><span class="hljs-comment"># 如果类面没有写__init__方法，Python会自动创建，但是不执行任何操作，</span><br><span class="hljs-comment"># 如果为了能够在完成自己想要的功能，可以自己定义__init__方法，</span><br><span class="hljs-comment"># 所以一个类里无论自己是否编写__init__方法 一定有__init__方法。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; 方法，用来做变量初始化 或 赋值 操作，在类实例化对象的时候，会被自动调用&quot;&quot;&quot;</span><br>    self.name = <span class="hljs-string">&quot;泰达米尔&quot;</span> <span class="hljs-comment"># 姓名</span><br>    self.hp = <span class="hljs-number">2600</span> <span class="hljs-comment"># 生命值</span><br>    self.atk = <span class="hljs-number">450</span>  <span class="hljs-comment"># 攻击力</span><br>    self.armor = <span class="hljs-number">200</span>  <span class="hljs-comment"># 护甲值</span><br></code></pre></td></tr></table></figure><ul><li><code>__init__()</code>方法，在创建一个对象时默认被调用，不需要手动调用</li><li><code>__init__(self)</code>中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去。</li><li>在类内部获取 属性 和 实例方法，通过self获取；</li><li>在类外部获取 属性 和 实例方法，通过对象名获取。</li><li>如果一个类有多个对象，每个对象的属性是各自保存的，都有各自独立的地址；</li><li>但是实例方法是所有对象共享的，只占用一份内存空间。类会通过self来判断是哪个对象调用了实例方法。</li></ul><blockquote><p><code>__str__(self)</code></p></blockquote><p>类似于toString方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        这个方法是一个魔法方法 (Magic Method) ，用来显示信息</span><br><span class="hljs-string">        该方法需要 return 一个数据，并且只有self一个参数，当在类的外部 print(对象) 则打印这个数据</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;英雄 &lt;%s&gt; 数据： 生命值 %d, 攻击力 %d, 护甲值 %d&quot;</span> % (self.name, self.hp, self.atk, self.armor)<br></code></pre></td></tr></table></figure><ul><li>在python中方法名如果是<code>__xxxx__()</code>的，那么就有特殊的功能，因此叫做“魔法”方法</li><li>当使用print输出对象的时候，默认打印对象的内存地址。如果类定义了<code>__str__(self)</code>方法，那么就会打印从在这个方法中 <code>return</code> 的数据</li><li><code>__str__</code>方法通常返回一个字符串，作为这个对象的描述信息</li></ul><blockquote><p>析构函数</p></blockquote><p><code>__del__()</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 当对象被删除时，会自动被调用</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;__del__方法被调用&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s 被 GM 干掉了...&quot;</span> % self.name)<br></code></pre></td></tr></table></figure><ul><li>当有变量保存了一个对象的引用时，此对象的引用计数就会加1；</li><li>当使用del() 删除变量指向的对象时，则会减少对象的引用计数。如果对象的引用计数不为1，那么会让这个对象的引用计数减1，当对象的引用计数为0的时候，则对象才会被真正删除（内存被回收）。</li></ul><blockquote><p>类属性</p></blockquote><p>写在类里面的属性是静态的，写在构造函数里面的是成员变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    address = <span class="hljs-string">&#x27;山东&#x27;</span>  <span class="hljs-comment"># 类属性</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.name = <span class="hljs-string">&#x27;xiaowang&#x27;</span>  <span class="hljs-comment"># 实例属性</span><br>        self.age = <span class="hljs-number">20</span>  <span class="hljs-comment"># 实例属性</span><br></code></pre></td></tr></table></figure><blockquote><p>类方法</p></blockquote><p>是类对象所拥有的方法，需要用修饰器<code>@classmethod</code>来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以<code>cls</code>作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以’cls’作为第一个参数的名字，就最好用’cls’了），能够通过实例对象和类对象去访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    country = <span class="hljs-string">&#x27;china&#x27;</span><br><br>    <span class="hljs-comment">#类方法，用classmethod来进行修饰</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_country</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-keyword">return</span> cls.country<br></code></pre></td></tr></table></figure><p>当方法中 需要使用类对象 (如访问私有类属性等)时，定义类方法<br>类方法一般和类属性配合使用</p><blockquote><p>静态方法</p></blockquote><p>需要通过修饰器<code>@staticmethod</code>来进行修饰，静态方法不需要多定义参数，可以通过对象和类来访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    country = <span class="hljs-string">&#x27;china&#x27;</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-comment">#静态方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_country</span>():<br>        <span class="hljs-keyword">return</span> People.country<br></code></pre></td></tr></table></figure><p>当方法中 既不需要使用实例对象(如实例对象，实例属性)，也不需要使用类对象 (如类属性、类方法、创建实例等)时，定义静态方法取消不需要的参数传递，有利于 减少不必要的内存占用和性能消耗</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><blockquote><p>封装的意义：</p></blockquote><ol><li>将属性和方法放到一起做为一个整体，然后通过实例化对象来处理；</li><li>隐藏内部实现细节，只需要和对象及其属性和方法交互就可以了；</li><li>对类的属性和方法增加 访问权限控制。</li></ol><blockquote><p>私有权限：在属性名和方法名 前面 加上两个下划线 __</p></blockquote><ol><li>类的私有属性 和 私有方法，都不能通过对象直接访问，但是可以在本类内部访问；</li><li>类的私有属性 和 私有方法，都不会被子类继承，子类也无法访问；</li><li>私有属性 和 私有方法 往往用来处理类的内部事情，不通过对象处理，起到安全作用。</li></ol><blockquote><p>修改私有属性的值</p></blockquote><p>Getter</p><p>Setter</p><blockquote><p>总结</p></blockquote><ul><li>Python中没有像C++中 public 和 private 这些关键字来区别公有属性和私有属性。</li><li>Python是以属性命名方式来区分，如果在属性和方法名前面加了2个下划线’__’，则表明该属性和方法是私有权限，否则为公有权限。</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.num = <span class="hljs-number">10</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_num</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.num + <span class="hljs-number">10</span>)<br><span class="hljs-comment"># 子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><ul><li><p>子类在继承的时候，在定义类时，小括号()中为父类的名字</p></li><li><p>父类的属性、方法，会被继承给子类</p></li><li><p>多继承可以继承多个父类，也继承了所有父类的属性和方法</p></li><li><p>注意：如果多个父类中有同名的 属性和方法，则<strong>默认使用第一个父类</strong>的属性和方法（根据类的魔法属性<strong>mro</strong>的顺序来查找）</p></li><li><p>多个父类中，不重名的属性和方法，不会有任何影响。</p></li></ul><blockquote><p>重写</p></blockquote><p>如果子类和父类的方法名和属性名相同，则默认使用子类的</p><blockquote><p>调用父类属性方法</p></blockquote><p>调用父类方法格式：父类类名.父类方法(self)</p><p>无论何时何地，self都表示是子类的对象。在调用父类方法时，通过传递self参数，来控制方法和属性的访问修改。</p><p>也可以使用super()方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"># super()的简化版，只支持新式类<br>super()<span class="hljs-selector-class">.__init__</span>()  # 执行父类的 __init__方法<br>super()<span class="hljs-selector-class">.make_cake</span>()  # 执行父类的 实例方法<br>self<span class="hljs-selector-class">.make_cake</span>()  # 执行本类的实例方法<br></code></pre></td></tr></table></figure><p>子类继承了多个父类，如果父类类名修改了，那么子类也要涉及多次修改。而且需要重复写多次调用，显得代码臃肿。</p><p>使用super() 可以逐一调用所有的父类方法，并且只执行一次。调用顺序遵循 <strong>mro</strong> 类属性的顺序。</p><p><strong>注意：如果继承了多个父类，且父类都有同名方法，则默认只执行第一个父类的(同名方法只执行一次，目前super()不支持执行多个父类的同名方法)</strong></p><p>super() 在Python2.3之后才有的机制，用于通常单继承的多层继承。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>和C++、Java一样，特殊的一种继承</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>跟C++、Java一样</p><blockquote><p>捕获异常</p></blockquote><p>try-except-else-finally</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-----test--1---&#x27;</span>)<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;123.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)  <span class="hljs-comment"># 如果123.txt文件不存在，那么会产生 IOError 异常</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-----test--2---&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(num)  <span class="hljs-comment"># 如果num变量没有定义，那么会产生 NameError 异常</span><br>    <span class="hljs-keyword">except</span> (IOError, NameError):<br>        <span class="hljs-comment"># 如果想通过一次except捕获到多个异常可以用一个元组的方式</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;捕获异常&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;没有出现到异常，真高兴&#x27;</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        f.close()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;关闭文件&#x27;</span>)<br><span class="hljs-keyword">except</span> NameError <span class="hljs-keyword">as</span> result:  <span class="hljs-comment"># 捕获所有异常并存储异常的详细信息</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有这个文件&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在Python中有一个概念叫做模块（module），这个和C语言中的头文件以及Java中的包类似</p><ul><li><p>在Python中用关键字<code>import</code>来引入某个模块，比如要引用模块math，就可以在文件最开始的地方用import math来引入。</p></li><li><p>可以根据__name__变量的结果能够判断出，是直接执行的python脚本还是被引入执行的，从而能够有选择性的执行测试代码</p></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">if</span> __name__ == <span class="hljs-string">&#x27;main&#x27;</span>:<br><span class="hljs-comment"># 测试代码</span><br></code></pre></td></tr></table></figure><ul><li><p>如果一个文件中有__all__变量，那么也就意味着这个变量中的元素，会被from xxx import *时导入,没有在这个变量中的不会被导入</p></li><li><p>包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为<code>__init__.py</code> 文件，那么这个文件夹就称之为<code>包</code></p></li><li><p>有效避免模块名称冲突问题，让应用组织结构更加清晰</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySring</title>
    <link href="/2022/07/04/MySpring/"/>
    <url>/2022/07/04/MySpring/</url>
    
    <content type="html"><![CDATA[<h1 id="1-注解类"><a href="#1-注解类" class="headerlink" title="1. 注解类"></a>1. 注解类</h1><p>Spring有三个常用注解分别是@Component、@ComponentScan、@Autowired</p><h2 id="1-1-Component"><a href="#1-1-Component" class="headerlink" title="1.1 @Component"></a>1.1 @Component</h2><p>@Component注解的作用是给要注入SpringIOC容器的类做标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Component &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-ComponentScan"><a href="#1-2-ComponentScan" class="headerlink" title="1.2 @ComponentScan"></a>1.2 @ComponentScan</h2><p>@ComponentScan用来扫描指定路径下的类是否包含@Component注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ComponentScan &#123;<br>    String <span class="hljs-title function_">basePackages</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-Autowired"><a href="#1-3-Autowired" class="headerlink" title="1.3 @Autowired"></a>1.3 @Autowired</h2><p>@Autowired用来自动给某个属性注入被Component标记的类对象</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.FIELD)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br>public <span class="hljs-variable">@interface</span> Autowired &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-ApplicationContext"><a href="#2-ApplicationContext" class="headerlink" title="2. ApplicationContext"></a>2. ApplicationContext</h1><p>ApplicationContext因此也称之为Spring上下文。Spring容器负责管理Bean与Bean之间的依赖关系。</p><p>这个类需要做两件事情</p><ol><li>扫描配置信息中指定包下的类</li><li>实例化扫描到的类</li></ol><p><img src="/./MySpring.assets/image-20220701155157100.png" alt="image-20220701155157100"></p><h2 id="2-1-扫描类信息"><a href="#2-1-扫描类信息" class="headerlink" title="2.1 扫描类信息"></a>2.1 扫描类信息</h2><p>首先我们先做扫描类信息的功能，扫描类信息需要做两件事</p><ol><li>解析配置类获取到我指定的扫描包路径</li><li>使用获取到的扫描包路径进行文件遍历操作如果是目录则递归进行2否则进入3</li><li>被Component注解标识的类进行注册</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.扫描配置信息中指定包下的类</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(Class&lt;?&gt; configClass)</span> &#123;<br>    <span class="hljs-comment">// 解析配置类，获取到扫描包路径</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">basePackages</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getBasePackages(configClass);<br>    <span class="hljs-comment">// 使用扫描包路径进行文件遍历操作</span><br>    <span class="hljs-built_in">this</span>.doScan(basePackages);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-1-解析配置类，获取到扫描包路径"><a href="#2-1-1-解析配置类，获取到扫描包路径" class="headerlink" title="2.1.1 解析配置类，获取到扫描包路径"></a>2.1.1 解析配置类，获取到扫描包路径</h3><p>这个就是简单获取配置类中@ComponentScan注解的basePackages值</p><p>使用反射机制解析注解的步骤：</p><ol><li>获取被注解注释的类对象<br><code>Class&lt;Annotation&gt; annotationClass = Annotation.class;</code></li><li>获取这个类对象中的注解对象<br><code>MyAnnotation myAnnotation = annotationClass.getAnnotation(MyAnnotation.class);</code></li><li>调用注解对象的方法获取属性值<br><code>myAnnotation.num()</code></li></ol><p>第一步不用做因为注解类是作为参数直接传入的，所以我们只需要做后两步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解析配置类，获取到扫描包路径</span><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">getBasePackages</span><span class="hljs-params">(Class&lt;?&gt; configClass)</span> &#123;<br>    <span class="hljs-comment">// 获取这个类对象中的注解对象</span><br>    <span class="hljs-type">ComponentScan</span> <span class="hljs-variable">componentScan</span> <span class="hljs-operator">=</span> configClass.getAnnotation(ComponentScan.class);<br>    <span class="hljs-comment">// 调用注解对象的方法获取属性值</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">basePackages</span> <span class="hljs-operator">=</span> componentScan.basePackages();<br>    <span class="hljs-keyword">return</span> basePackages;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-2-使用扫描包路径进行文件遍历操作"><a href="#2-1-2-使用扫描包路径进行文件遍历操作" class="headerlink" title="2.1.2 使用扫描包路径进行文件遍历操作"></a>2.1.2 使用扫描包路径进行文件遍历操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用扫描包路径进行文件遍历操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doScan</span><span class="hljs-params">(String basePackages)</span> &#123;<br>    <span class="hljs-comment">// 将.转化为/</span><br>    String[] split = basePackages.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;/src/&quot;</span> +  split[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; split.length; i++) &#123;<br>        filePath += <span class="hljs-string">&quot;/&quot;</span> + split[i];<br>    &#125;<br><br><br>    <span class="hljs-comment">// 获取资源信息</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>    <span class="hljs-keyword">for</span> (File file : dir.listFiles()) &#123;<br>        <span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>            <span class="hljs-comment">// 递归扫描</span><br>            doScan(basePackages + <span class="hljs-string">&quot;.&quot;</span> + file.getName());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// com.my.spring.example + . + Boy.class -&gt; com.my.spring.example.Boy</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> basePackages + <span class="hljs-string">&quot;.&quot;</span> + file.getName().replace(<span class="hljs-string">&quot;.java&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>            <span class="hljs-comment">// 将class存放到classMap中</span><br>            <span class="hljs-built_in">this</span>.registerClass(className);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-3-注册含有Component注解的类"><a href="#2-1-3-注册含有Component注解的类" class="headerlink" title="2.1.3 注册含有Component注解的类"></a>2.1.3 注册含有Component注解的类</h3><p>我们需要注册也就是存储含有Component的类，这里为了保证线程安全采用了ConcurrentHashMap</p><p>步骤：</p><ol><li>使用类加载器通过类名加载类信息</li><li>获取这个类的Component注解</li><li>如果存在Component注解则将其放入类信息池中</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 如果该类含有Component注解那么就将其加入到classMap中</span><br><span class="hljs-keyword">private</span> void register<span class="hljs-constructor">Class(String <span class="hljs-params">className</span>)</span>&#123;<br>    <span class="hljs-comment">// 使用类加载器通过类名加载类信息</span><br>    ClassLoader classLoader = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ClassLoader</span>.</span></span>get<span class="hljs-constructor">SystemClassLoader()</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Class&lt;?&gt; clazz = classLoader.load<span class="hljs-constructor">Class(<span class="hljs-params">className</span>)</span>;<br>        <span class="hljs-comment">// 获取这个类的Component注解</span><br>        Component component = clazz.get<span class="hljs-constructor">Annotation(Component.<span class="hljs-params">class</span>)</span>;<br>        <span class="hljs-comment">// 如果存在Component注解则将其放入类信息池中</span><br>        <span class="hljs-keyword">if</span> (component != null) &#123;<br>            classPool.put(className,clazz);<br>        &#125;<br>    &#125; catch (ClassNotFoundException e) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;类加载失败&quot;</span>);<br>        e.print<span class="hljs-constructor">StackTrace()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-实例化扫描到的类"><a href="#2-2-实例化扫描到的类" class="headerlink" title="2.2 实例化扫描到的类"></a>2.2 实例化扫描到的类</h2><p>首先我们要用一个ConcurrentHashMap来存储bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个线程安全的类对象池</span><br><span class="hljs-keyword">private</span> Map&lt;String, Object&gt; beanPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><blockquote><p>流程图：</p></blockquote><p><img src="/./MySpring.assets/image-20220701175424802.png" alt="image-20220701175424802"></p><h3 id="2-2-1-实例化扫描到的类"><a href="#2-2-1-实例化扫描到的类" class="headerlink" title="2.2.1 实例化扫描到的类"></a>2.2.1 实例化扫描到的类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2. 实例化扫描到的类</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instantiateBean</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 将classPool中的所有值都实例化，并获取</span><br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : classPool.values()) &#123;<br>        getBean(clazz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-获取bean对象"><a href="#2-2-2-获取bean对象" class="headerlink" title="2.2.2 获取bean对象"></a>2.2.2 获取bean对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>    <span class="hljs-comment">// 先从缓存中获取</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> beanPool.get(clazz.getName());<br>    <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> bean;<br>    <span class="hljs-comment">// 如果没有则创建</span><br>    <span class="hljs-keyword">return</span> createBean(clazz);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-3-创建bean对象"><a href="#2-2-3-创建bean对象" class="headerlink" title="2.2.3 创建bean对象"></a>2.2.3 创建bean对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建bean对象</span><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>    <span class="hljs-comment">// 1. 实例化bean</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.newInstance(clazz);<br>    <span class="hljs-comment">// 2. 填充字段，将含有Autowired注解的字段注入bean对象</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">this</span>.populateBean(bean, clazz);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">// 3. 实例好并且注入完的bean放入beanPool中</span><br>    beanPool.put(clazz.getName(),bean);<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-4-实例化bean"><a href="#2-2-4-实例化bean" class="headerlink" title="2.2.4 实例化bean"></a>2.2.4 实例化bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        bean = clazz.getDeclaredConstructor().newInstance();<br>    &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;bean实例化失败&quot;</span>);<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;bean实例化失败&quot;</span>);<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;bean实例化失败&quot;</span>);<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>        System.out.println(<span class="hljs-string">&quot;bean实例化失败&quot;</span>);<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-5-填充字段，将含有Autowired注解的字段注入bean对象"><a href="#2-2-5-填充字段，将含有Autowired注解的字段注入bean对象" class="headerlink" title="2.2.5 填充字段，将含有Autowired注解的字段注入bean对象"></a>2.2.5 填充字段，将含有Autowired注解的字段注入bean对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 填充字段，将含有Autowired注解的字段注入bean对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">populateBean</span><span class="hljs-params">(Object bean, Class&lt;?&gt; clazz)</span> <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>    <span class="hljs-comment">// 解析class信息，判断类中是否有需要进行依赖注入的字段</span><br>    Field[] fields = clazz.getDeclaredFields();<br>    <span class="hljs-comment">// 遍历每一个属性</span><br>    <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>        <span class="hljs-comment">// 获取属性的Autowired注解</span><br>        <span class="hljs-type">Autowired</span> <span class="hljs-variable">autowired</span> <span class="hljs-operator">=</span> field.getAnnotation(Autowired.class);<br>        <span class="hljs-comment">// 如果有Autowired这个注解</span><br>        <span class="hljs-keyword">if</span> (autowired != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 解析这个属性对应的类</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> resolveBean(field.getType());<br>            <span class="hljs-comment">// 爆破，因为属性可能是private</span><br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">// 将value值保存到bean对象的属性中</span><br>            field.set(bean,value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-6-解析bean用来实现声明接口时注入其子类对象"><a href="#2-2-6-解析bean用来实现声明接口时注入其子类对象" class="headerlink" title="2.2.6 解析bean用来实现声明接口时注入其子类对象"></a>2.2.6 解析bean用来实现声明接口时注入其子类对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解析bean用来实现声明接口时注入其子类对象</span><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">resolveBean</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span>&#123;<br>    <span class="hljs-comment">// 判断clazz是不是一个接口</span><br>    <span class="hljs-keyword">if</span> (clazz.isInterface()) &#123;<br>        <span class="hljs-comment">// 遍历classPool</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String,Class&lt;?&gt;&gt; entry : classPool.entrySet()) &#123;<br>            <span class="hljs-comment">// 如果clazz对应的类是entry对应的类的父类或接口</span><br>            <span class="hljs-keyword">if</span> (clazz.isAssignableFrom(entry.getValue())) &#123;<br>                <span class="hljs-keyword">return</span> getBean(entry.getValue());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;找不到可以注入的bean&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> getBean(clazz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-组合"><a href="#2-3-组合" class="headerlink" title="2.3 组合"></a>2.3 组合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationContext</span> &#123;<br><br>    <span class="hljs-comment">// 定义一个线程安全的类信息池</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; classPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 定义一个线程安全的类对象池</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; beanPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ApplicationContext</span><span class="hljs-params">(Class&lt;?&gt; configClass)</span> &#123;<br>        <span class="hljs-comment">// 1.扫描配置信息中指定包下的类</span><br>        <span class="hljs-built_in">this</span>.scan(configClass);<br>        <span class="hljs-comment">// 2.实例化扫描到的类</span><br>        <span class="hljs-built_in">this</span>.instantiateBean();<br>    &#125;<br><br><br><br>    <span class="hljs-comment">// 1.扫描配置信息中指定包下的类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(Class&lt;?&gt; configClass)</span> &#123;<br>        <span class="hljs-comment">// 解析配置类，获取到扫描包路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">basePackages</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getBasePackages(configClass);<br>        <span class="hljs-comment">// 使用扫描包路径进行文件遍历操作</span><br>        <span class="hljs-built_in">this</span>.doScan(basePackages);<br>    &#125;<br><br>    <span class="hljs-comment">// 解析配置类，获取到扫描包路径</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getBasePackages</span><span class="hljs-params">(Class&lt;?&gt; configClass)</span> &#123;<br>        <span class="hljs-comment">// 获取这个类对象中的注解对象</span><br>        <span class="hljs-type">ComponentScan</span> <span class="hljs-variable">componentScan</span> <span class="hljs-operator">=</span> configClass.getAnnotation(ComponentScan.class);<br>        <span class="hljs-comment">// 调用注解对象的方法获取属性值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">basePackages</span> <span class="hljs-operator">=</span> componentScan.basePackages();<br>        <span class="hljs-keyword">return</span> basePackages;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用扫描包路径进行文件遍历操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doScan</span><span class="hljs-params">(String basePackages)</span> &#123;<br>        <span class="hljs-comment">// 将.转化为/</span><br>        String[] split = basePackages.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;/src/&quot;</span> +  split[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; split.length; i++) &#123;<br>            filePath += <span class="hljs-string">&quot;/&quot;</span> + split[i];<br>        &#125;<br><br><br>        <span class="hljs-comment">// 获取资源信息</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">for</span> (File file : dir.listFiles()) &#123;<br>            <span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>                <span class="hljs-comment">// 递归扫描</span><br>                doScan(basePackages + <span class="hljs-string">&quot;.&quot;</span> + file.getName());<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// com.my.spring.example + . + Boy.class -&gt; com.my.spring.example.Boy</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> basePackages + <span class="hljs-string">&quot;.&quot;</span> + file.getName().replace(<span class="hljs-string">&quot;.java&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>                <span class="hljs-comment">// 将class存放到classMap中</span><br>                <span class="hljs-built_in">this</span>.registerClass(className);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果该类含有Component注解那么就将其加入到classMap中</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerClass</span><span class="hljs-params">(String className)</span>&#123;<br>        <span class="hljs-comment">// 使用类加载器通过类名加载类信息</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = classLoader.loadClass(className);<br>            <span class="hljs-comment">// 获取这个类的Component注解</span><br>            <span class="hljs-type">Component</span> <span class="hljs-variable">component</span> <span class="hljs-operator">=</span> clazz.getAnnotation(Component.class);<br>            <span class="hljs-comment">// 如果存在Component注解则将其放入类信息池中</span><br>            <span class="hljs-keyword">if</span> (component != <span class="hljs-literal">null</span>) &#123;<br>                classPool.put(className,clazz);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;类加载失败&quot;</span>);<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 实例化扫描到的类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instantiateBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 将classPool中的所有值都实例化，并获取</span><br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : classPool.values()) &#123;<br>            getBean(clazz);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取bean对象</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">// 先从缓存中获取</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> beanPool.get(clazz.getName());<br>        <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> bean;<br>        <span class="hljs-comment">// 如果没有则创建</span><br>        <span class="hljs-keyword">return</span> createBean(clazz);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建bean对象</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">// 1. 实例化bean</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.newInstance(clazz);<br>        <span class="hljs-comment">// 2. 填充字段，将含有Autowired注解的字段注入bean对象</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.populateBean(bean, clazz);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">// 3. 实例好并且注入完的bean放入beanPool中</span><br>        beanPool.put(clazz.getName(),bean);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-comment">// 实例化bean</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bean = clazz.getDeclaredConstructor().newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;bean实例化失败&quot;</span>);<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;bean实例化失败&quot;</span>);<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;bean实例化失败&quot;</span>);<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;bean实例化失败&quot;</span>);<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-comment">// 填充字段，将含有Autowired注解的字段注入bean对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">populateBean</span><span class="hljs-params">(Object bean, Class&lt;?&gt; clazz)</span> <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>        <span class="hljs-comment">// 解析class信息，判断类中是否有需要进行依赖注入的字段</span><br>        Field[] fields = clazz.getDeclaredFields();<br>        <span class="hljs-comment">// 遍历每一个属性</span><br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            <span class="hljs-comment">// 获取属性的Autowired注解</span><br>            <span class="hljs-type">Autowired</span> <span class="hljs-variable">autowired</span> <span class="hljs-operator">=</span> field.getAnnotation(Autowired.class);<br>            <span class="hljs-comment">// 如果有Autowired这个注解</span><br>            <span class="hljs-keyword">if</span> (autowired != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 解析这个属性对应的类</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> resolveBean(field.getType());<br>                <span class="hljs-comment">// 爆破，因为属性可能是private</span><br>                field.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 将value值保存到bean对象的属性中</span><br>                field.set(bean,value);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 解析bean用来实现声明接口时注入其子类对象</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">resolveBean</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span>&#123;<br>        <span class="hljs-comment">// 判断clazz是不是一个接口</span><br>        <span class="hljs-keyword">if</span> (clazz.isInterface()) &#123;<br>            <span class="hljs-comment">// 遍历classPool</span><br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;String,Class&lt;?&gt;&gt; entry : classPool.entrySet()) &#123;<br>                <span class="hljs-comment">// 如果clazz对应的类是entry对应的类的父类或接口</span><br>                <span class="hljs-keyword">if</span> (clazz.isAssignableFrom(entry.getValue())) &#123;<br>                    <span class="hljs-keyword">return</span> getBean(entry.getValue());<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;找不到可以注入的bean&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> getBean(clazz);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-包结构以及测试结果"><a href="#3-包结构以及测试结果" class="headerlink" title="3. 包结构以及测试结果"></a>3. 包结构以及测试结果</h1><p><img src="/MySpring.assets/image-20220701175612955.png" alt="image-20220701175612955"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2022/07/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2022/07/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="我的第一篇博客文章"><a href="#我的第一篇博客文章" class="headerlink" title="我的第一篇博客文章"></a>我的第一篇博客文章</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/02/hello-world/"/>
    <url>/2022/07/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
